<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[8b/10b编解码器的Verilog实现]]></title>
    <url>%2Funcategorized%2F8b-10b%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E7%9A%84Verilog%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[我用于测试的图片大小为 269*269 的，如果你的图片大小不同，就还得修改一些地方。写的比较仓促，我水平也有限，将就参考参考吧 这是我用于测试的图片： 8b/10b 编码器首先生成需要编码的文件，这个文件以 0xBC 为同步码，以 0xFD 为帧头，以 0xFB 为帧尾，帧头和帧尾之间包含 64 字节的数据，数据包于数据包之间的同步码为 8 个，这个地方我用 C++ 和 OpenCV 实现，代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495// get_data.cpp: 定义控制台应用程序的入口点。//#include "stdafx.h"#include &lt;opencv2/opencv.hpp&gt;#include &lt;fstream&gt;using namespace cv;using namespace std;void same_step(ofstream &amp;ofs);void begin_data(ofstream &amp;ofs);void end_data(ofstream &amp;ofs);bool send_data(ofstream &amp;ofs, Mat_&lt;uchar&gt;::iterator &amp;it_begin, Mat_&lt;uchar&gt;::iterator &amp;it_end);int main()&#123; Mat img = imread("1.jpg"); if (!img.data) &#123; cout &lt;&lt; "当前文件夹下没有命名为 1.jpg 的图片存在" &lt;&lt; endl; return -1; &#125; cvtColor(img, img, COLOR_BGR2GRAY); ofstream out; out.open("./data.txt"); Mat_&lt;uchar&gt;::iterator it_begin = img.begin&lt;uchar&gt;(); Mat_&lt;uchar&gt;::iterator it_end = img.end&lt;uchar&gt;(); same_step(out); while (1) &#123; if (it_begin != it_end) &#123; begin_data(out); if (send_data(out, it_begin, it_end)) &#123; end_data(out); same_step(out); &#125; else &#123; end_data(out); same_step(out); break; &#125; &#125; else &#123; break; &#125; &#125; imshow("img", img); waitKey(0); return 0;&#125;void same_step(ofstream &amp;ofs)&#123; for (int i = 0; i &lt; 8; ++i) ofs &lt;&lt; int(0xBC) &lt;&lt; endl;&#125;void begin_data(ofstream &amp;ofs)&#123; ofs &lt;&lt; int(0xFD) &lt;&lt; endl;&#125;void end_data(ofstream &amp;ofs)&#123; ofs &lt;&lt; int(0xFB) &lt;&lt; endl;&#125;bool send_data(ofstream &amp;ofs, Mat_&lt;uchar&gt;::iterator &amp;it_begin, Mat_&lt;uchar&gt;::iterator &amp;it_end)&#123; for (int i = 0; i &lt; 64; ++i) &#123; if (it_begin != it_end) &#123; ofs &lt;&lt; int(*it_begin) &lt;&lt; endl; ++it_begin; &#125; else &#123; ofs &lt;&lt; int(0xFB) &lt;&lt; endl; &#125; &#125; if (it_begin != it_end) return true; else return false;&#125; 运行这个程序就可以生成名为 data.txt 的待编码文件，下面用 Verilog 实现编码器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350`timescale 1ns / 1ps//////////////////////////////////////////////////////////////////////////////////// Company: // Engineer: // // Create Date: 2018/12/13 16:17:52// Design Name: // Module Name: top// Project Name: // Target Devices: // Tool Versions: // Description: // // Dependencies: // // Revision:// Revision 0.01 - File Created// Additional Comments:// //////////////////////////////////////////////////////////////////////////////////module top( input [7:0] data_i, input clk, output [9:0] data_o ); reg [9:0] trans_data = &#123;2'b01, 8'hbc&#125;; reg [15:0] clk_cnt = 0; reg clk2MHz = 0; always @(posedge clk) begin if (clk_cnt != 250) clk_cnt &lt;= clk_cnt + 1; else begin clk2MHz &lt;= ~clk2MHz; clk_cnt &lt;= 0; end end always @(data_i) begin clk2MHz &lt;= 0; clk_cnt &lt;= 0; end reg [7:0] same_step_cnt = 0; reg [7:0] data_cnt = 0; parameter INIT = 3'b000; parameter STATE_JUDGE = 3'b101; reg [2:0] cur_state = INIT; reg [7:0] data_buf; reg trans_flag = 0; always @(posedge clk2MHz) begin case (cur_state) INIT: begin data_buf &lt;= data_i; cur_state &lt;= STATE_JUDGE; trans_data &lt;= &#123;2'b01, 8'hbc&#125;; end STATE_JUDGE: begin if (data_buf == 8'hbc &amp;&amp; data_i == 8'hbc &amp;&amp; data_cnt == 0) begin trans_data &lt;= &#123;2'b01, 8'hbc&#125;; data_buf &lt;= data_i; end else if (data_buf == 8'hbc &amp;&amp; data_i == 8'hfd &amp;&amp; data_cnt == 0) begin trans_data &lt;= &#123;2'b01, 8'hfd&#125;; data_buf &lt;= data_i; end else if (data_buf == 8'hfb &amp;&amp; data_i == 8'hbc &amp;&amp; data_cnt == 0) begin trans_data &lt;= &#123;2'b01, 8'hbc&#125;; data_buf &lt;= data_i; end else begin if (data_cnt != 64) begin trans_data &lt;= &#123;2'b00, data_i&#125;; data_cnt &lt;= data_cnt + 1; data_buf &lt;= data_i; end else begin trans_data &lt;= &#123;2'b01, 8'hfb&#125;; data_cnt &lt;= 0; data_buf &lt;= data_i; end end end endcase trans_flag &lt;= ~trans_flag; end data_encoder encoder_( .clk(clk), .i_data(trans_data), .o_data(data_o), .trans_triger(trans_flag) );endmodulemodule data_encoder( input clk, input [9:0] i_data, input trans_triger, output reg [9:0] o_data ); parameter DATA526 = 4'b0000; parameter DATA324 = 4'b0001; parameter JUDGE526 = 4'b0010; parameter JUDGE324 = 4'b0011; parameter JUDGECODE = 4'b0100; parameter K8210 = 4'b0101; parameter KJUDGE = 4'b0110; reg [3:0] cur_state = JUDGECODE, next_state = JUDGECODE; reg rd_flag = 0; reg trans_flag = 1; always @(trans_triger) begin trans_flag &lt;= 1; end always @(posedge clk) begin if (trans_flag) cur_state &lt;= next_state; end always @(cur_state) begin case (cur_state) JUDGECODE: begin if (i_data[9:8] == 2'b00) next_state &lt;= DATA526; else if (i_data[9:8] == 2'b01) next_state &lt;= K8210; else begin trans_flag &lt;= 0; next_state &lt;= JUDGECODE; end end DATA526: begin o_data[9:4] &lt;= encoder526(i_data[4:0]); next_state &lt;= JUDGE526; end DATA324: begin o_data[3:0] &lt;= encoder324(i_data[7:5]); next_state &lt;= JUDGE324; end JUDGE526: begin if (o_data[9] + o_data[8] + o_data[7] + o_data[6] + o_data[5] + o_data[4] != 3) rd_flag &lt;= ~rd_flag; next_state &lt;= DATA324; end JUDGE324: begin if (o_data[3] + o_data[2] + o_data[1] + o_data[0] != 2) rd_flag &lt;= ~rd_flag; next_state &lt;= JUDGECODE; trans_flag &lt;= 0; end K8210: begin o_data &lt;= kencoder(i_data); next_state &lt;= KJUDGE; end KJUDGE: begin if (o_data[0] + o_data[1] + o_data[2] + o_data[3] + o_data[4] + o_data[5] + o_data[6] + o_data[7] + o_data[8] + o_data[9] != 5) rd_flag &lt;= ~rd_flag; next_state &lt;= JUDGECODE; trans_flag &lt;= 0; end endcase end function [5:0] encoder526; input [4:0] i_data526; if (rd_flag == 0) case (i_data526) 5'b00000: encoder526 = 6'b100111; 5'b00001: encoder526 = 6'b011101; 5'b00010: encoder526 = 6'b101101; 5'b00011: encoder526 = 6'b110001; 5'b00100: encoder526 = 6'b110101; 5'b00101: encoder526 = 6'b101001; 5'b00110: encoder526 = 6'b011001; 5'b00111: encoder526 = 6'b111000; 5'b01000: encoder526 = 6'b111001; 5'b01001: encoder526 = 6'b100101; 5'b01010: encoder526 = 6'b010101; 5'b01011: encoder526 = 6'b110100; 5'b01100: encoder526 = 6'b001101; 5'b01101: encoder526 = 6'b101100; 5'b01110: encoder526 = 6'b011100; 5'b01111: encoder526 = 6'b010111; 5'b10000: encoder526 = 6'b011011; 5'b10001: encoder526 = 6'b100011; 5'b10010: encoder526 = 6'b010011; 5'b10011: encoder526 = 6'b110010; 5'b10100: encoder526 = 6'b001011; 5'b10101: encoder526 = 6'b101010; 5'b10110: encoder526 = 6'b011010; 5'b10111: encoder526 = 6'b111010; 5'b11000: encoder526 = 6'b110011; 5'b11001: encoder526 = 6'b100110; 5'b11010: encoder526 = 6'b010110; 5'b11011: encoder526 = 6'b110110; 5'b11100: encoder526 = 6'b001110; 5'b11101: encoder526 = 6'b101110; 5'b11110: encoder526 = 6'b011110; 5'b11111: encoder526 = 6'b101011; endcase else case (i_data526) 5'b00000: encoder526 = 6'b011000; 5'b00001: encoder526 = 6'b100010; 5'b00010: encoder526 = 6'b010010; 5'b00011: encoder526 = 6'b110001; 5'b00100: encoder526 = 6'b001010; 5'b00101: encoder526 = 6'b101001; 5'b00110: encoder526 = 6'b011001; 5'b00111: encoder526 = 6'b000111; 5'b01000: encoder526 = 6'b000110; 5'b01001: encoder526 = 6'b100101; 5'b01010: encoder526 = 6'b010101; 5'b01011: encoder526 = 6'b110100; 5'b01100: encoder526 = 6'b001101; 5'b01101: encoder526 = 6'b101100; 5'b01110: encoder526 = 6'b011100; 5'b01111: encoder526 = 6'b101000; 5'b10000: encoder526 = 6'b100100; 5'b10001: encoder526 = 6'b100011; 5'b10010: encoder526 = 6'b010011; 5'b10011: encoder526 = 6'b110010; 5'b10100: encoder526 = 6'b001011; 5'b10101: encoder526 = 6'b101010; 5'b10110: encoder526 = 6'b011010; 5'b10111: encoder526 = 6'b000101; 5'b11000: encoder526 = 6'b001100; 5'b11001: encoder526 = 6'b100110; 5'b11010: encoder526 = 6'b010110; 5'b11011: encoder526 = 6'b001001; 5'b11100: encoder526 = 6'b001110; 5'b11101: encoder526 = 6'b010001; 5'b11110: encoder526 = 6'b100001; 5'b11111: encoder526 = 6'b010100; endcase endfunction function [3:0] encoder324; input [2:0] i_data324; if (rd_flag == 0) case (i_data324) 3'b000: encoder324 = 4'b1011; 3'b001: encoder324 = 4'b1001; 3'b010: encoder324 = 4'b0101; 3'b011: encoder324 = 4'b1100; 3'b100: encoder324 = 4'b1101; 3'b101: encoder324 = 4'b1010; 3'b110: encoder324 = 4'b0110; 3'b111: begin if (i_data[4:0] == 5'd17 || i_data[4:0] == 5'd18 || i_data[4:0] == 5'd20) encoder324 = 4'b0111; else encoder324 = 4'b1110; end endcase else case (i_data324) 3'b000: encoder324 = 4'b0100; 3'b001: encoder324 = 4'b1001; 3'b010: encoder324 = 4'b0101; 3'b011: encoder324 = 4'b0011; 3'b100: encoder324 = 4'b0010; 3'b101: encoder324 = 4'b1010; 3'b110: encoder324 = 4'b0110; 3'b111: begin if (i_data[4:0] == 5'd11 || i_data[4:0] == 5'd13 || i_data[4:0] == 5'd14) encoder324 = 4'b1000; else encoder324 = 4'b0001; end endcase endfunction function [9:0] kencoder; input [7:0] i_data; if (rd_flag == 0) begin case (i_data) 8'b00011100: kencoder = 10'b0011110100; 8'b00111100: kencoder = 10'b0011111001; 8'b01011100: kencoder = 10'b0011110101; 8'b01111100: kencoder = 10'b0011110011; 8'b10011100: kencoder = 10'b0011110010; 8'b10111100: kencoder = 10'b0011111010; 8'b11011100: kencoder = 10'b0011110110; 8'b11111100: kencoder = 10'b0011111000; 8'b11110111: kencoder = 10'b1110101000; 8'b11111011: kencoder = 10'b1101101000; 8'b11111101: kencoder = 10'b1011101000; 8'b11111110: kencoder = 10'b0111101000; endcase end else begin case (i_data) 8'b00011100: kencoder = 10'b1100001011; 8'b00111100: kencoder = 10'b1100000110; 8'b01011100: kencoder = 10'b1100001010; 8'b01111100: kencoder = 10'b1100001100; 8'b10011100: kencoder = 10'b1100001101; 8'b10111100: kencoder = 10'b1100000101; 8'b11011100: kencoder = 10'b1100001001; 8'b11111100: kencoder = 10'b1100000111; 8'b11110111: kencoder = 10'b0001010111; 8'b11111011: kencoder = 10'b0010010111; 8'b11111101: kencoder = 10'b0100010111; 8'b11111110: kencoder = 10'b1000010111; endcase end endfunctionendmodule 然后编写 testbench 进行仿真 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768`timescale 1ns / 1ps//////////////////////////////////////////////////////////////////////////////////// Company: // Engineer: // // Create Date: 2018/12/13 17:54:13// Design Name: // Module Name: tb// Project Name: // Target Devices: // Tool Versions: // Description: // // Dependencies: // // Revision:// Revision 0.01 - File Created// Additional Comments:// //////////////////////////////////////////////////////////////////////////////////module tb( ); reg [7:0] i_data = 8'hbc; wire [9:0] o_data; reg clk = 0; always clk = #0.5 ~clk; reg [31:0] cnt = 0; integer fp_r; integer fp_w; integer count; initial begin count = 0; fp_r = $fopen("D:/Mine/FPGA/data.txt", "r"); //这一行的地址为你刚刚生成的 data.txt 的地址 fp_w = $fopen("D:/Mine/FPGA/after_code.txt", "w"); //这一行的地址为编码后文件 after_code.txt 的输出地址 end always @(posedge clk) begin if (cnt != 500) cnt &lt;= cnt + 1; else begin $fscanf(fp_r, "%d", i_data); if (count != 0) $fwrite(fp_w, "%d\n", o_data); cnt &lt;= 0; if (count != 83702) //这个地方的数字改为你生成的 data.txt 文件里数据的个数 count &lt;= count + 1; else begin $fclose(fp_r); $fclose(fp_w); end end end top test( .clk(clk), .data_i(i_data), .data_o(o_data) );endmodule 仿真完成之后即可生成名为 after_code.txt 的编码之后的文件哦，对了！要运行这个仿真的话需要改一些地方，要改的地方我写注释里了 8b/10b 解码器首先用 Verilog 实现解码器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104`timescale 1ns / 1ps//////////////////////////////////////////////////////////////////////////////////// Company: // Engineer: // // Create Date: 2018/12/14 20:41:55// Design Name: // Module Name: decoder// Project Name: // Target Devices: // Tool Versions: // Description: // // Dependencies: // // Revision:// Revision 0.01 - File Created// Additional Comments:// //////////////////////////////////////////////////////////////////////////////////module decoder( input clk, input [9:0] data_i, output reg [7:0] data_o ); always @(posedge clk) begin case (data_i) 10'b0011110100, 10'b1100001011: data_o &lt;= 8'b00011100; 10'b0011111001, 10'b1100000110: data_o &lt;= 8'b00111100; 10'b0011110101, 10'b1100001010: data_o &lt;= 8'b01011100; 10'b0011110011, 10'b1100001100: data_o &lt;= 8'b01111100; 10'b0011110010, 10'b1100001101: data_o &lt;= 8'b10011100; 10'b0011111010, 10'b1100000101: data_o &lt;= 8'b10111100; 10'b0011110110, 10'b1100001001: data_o &lt;= 8'b11011100; 10'b0011111000, 10'b1100000111: data_o &lt;= 8'b11111100; 10'b1110101000, 10'b0001010111: data_o &lt;= 8'b11110111; 10'b1101101000, 10'b0010010111: data_o &lt;= 8'b11111011; 10'b1011101000, 10'b0100010111: data_o &lt;= 8'b11111101; 10'b0111101000, 10'b1000010111: data_o &lt;= 8'b11111110; default: begin data_o[4:0] &lt;= func_625(data_i[9:4]); data_o[7:5] &lt;= func_423(data_i[3:0]); end endcase end function [4:0] func_625; input [5:0] data_in; case (data_in) 6'b100111, 6'b011000: func_625 = 5'b00000; 6'b011101, 6'b100010: func_625 = 5'b00001; 6'b101101, 6'b010010: func_625 = 5'b00010; 6'b110001: func_625 = 5'b00011; 6'b110101, 6'b001010: func_625 = 5'b00100; 6'b101001: func_625 = 5'b00101; 6'b011001: func_625 = 5'b00110; 6'b111000, 6'b000111: func_625 = 5'b00111; 6'b111001, 6'b000110: func_625 = 5'b01000; 6'b100101: func_625 = 5'b01001; 6'b010101: func_625 = 5'b01010; 6'b110100: func_625 = 5'b01011; 6'b001101: func_625 = 5'b01100; 6'b101100: func_625 = 5'b01101; 6'b011100: func_625 = 5'b01110; 6'b010111, 6'b101000: func_625 = 5'b01111; 6'b011011, 6'b100100: func_625 = 5'b10000; 6'b100011: func_625 = 5'b10001; 6'b010011: func_625 = 5'b10010; 6'b110010: func_625 = 5'b10011; 6'b001011: func_625 = 5'b10100; 6'b101010: func_625 = 5'b10101; 6'b011010: func_625 = 5'b10110; 6'b111010, 6'b000101: func_625 = 5'b10111; 6'b110011, 6'b001100: func_625 = 5'b11000; 6'b100110: func_625 = 5'b11001; 6'b010110: func_625 = 5'b11010; 6'b110110, 6'b001001: func_625 = 5'b11011; 6'b001110: func_625 = 5'b11100; 6'b101110, 6'b010001: func_625 = 5'b11101; 6'b011110, 6'b100001: func_625 = 5'b11110; 6'b101011, 6'b010100: func_625 = 5'b11111; endcase endfunction function [2:0] func_423; input [3:0] data_in; case (data_in) 4'b1011, 4'b0100: func_423 = 3'b000; 4'b1001: func_423 = 3'b001; 4'b0101: func_423 = 3'b010; 4'b1100, 4'b0011: func_423 = 3'b011; 4'b1101, 4'b0010: func_423 = 3'b100; 4'b1010: func_423 = 3'b101; 4'b0110: func_423 = 3'b110; 4'b1110, 4'b0001: func_423 = 3'b111; 4'b0111, 4'b1000: func_423 = 3'b111; endcase endfunctionendmodule 然后编写 testbench 进行仿真 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778`timescale 1ns / 1ps//////////////////////////////////////////////////////////////////////////////////// Company: // Engineer: // // Create Date: 2018/12/14 20:42:10// Design Name: // Module Name: tb// Project Name: // Target Devices: // Tool Versions: // Description: // // Dependencies: // // Revision:// Revision 0.01 - File Created// Additional Comments:// //////////////////////////////////////////////////////////////////////////////////module tb( ); reg [9:0] data_i = 10'b0; wire [7:0] data_o; reg clk = 0; always clk = #0.5 ~clk; reg [31:0] cnt = 0; integer fp_r; integer fp_w; integer count; reg clk2MHz = 0; initial begin fp_r = $fopen("D:/Mine/FPGA/after_code.txt", "r");//这一行的地址为你刚刚生成的 after_code.txt 的地址 fp_w = $fopen("D:/Mine/FPGA/after_decode.txt", "w");//这一行的地址为解码后文件 after_decode.txt 的输出地址 count = 0; end always @(posedge clk) begin if (cnt != 500) begin cnt &lt;= cnt + 1; if (count != 0) begin if (cnt == 250) clk2MHz &lt;= ~clk2MHz; end end else begin $fscanf(fp_r, "%d", data_i); cnt &lt;= 0; if (count != 0) $fwrite(fp_w, "%d\n", data_o); clk2MHz &lt;= ~clk2MHz; if (count != 83702)//这个地方的数字改为你生成的 after_code.txt 文件里数据的个数 count &lt;= count + 1; else begin $fclose(fp_r); $fclose(fp_w); end end end decoder test( .clk(clk2MHz), .data_i(data_i), .data_o(data_o) );endmodule emmmmm… 这个仿真同样也有需要改动的地方，就在注释那仿真完成后即可得名为 after_decode.txt 的解码之后的文件，这个时候可以将 after_decode.txt 于 data.txt 进行比对，这两个文件的内容应该是一致的，然后就从 after_decode.txt 中恢复图片，这个地方仍用 C++ 和 OpenCV 实现，代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// recover.cpp: 定义控制台应用程序的入口点。//#include "stdafx.h"#include &lt;opencv2/opencv.hpp&gt;#include &lt;fstream&gt;#include &lt;iostream&gt;using namespace std;using namespace cv;uchar getdata(fstream &amp;);int main()&#123; fstream f("after_decode.txt", ios::in); int data; int data_pre; int rows, cols; cout &lt;&lt; "这个地方不要输错了，不然图片恢复不了" &lt;&lt; endl; cout &lt;&lt; "输入图片的高度："; cin &gt;&gt; rows; cout &lt;&lt; "输入图片的宽度："; cin &gt;&gt; cols; Mat img(rows, cols, CV_8UC1); for (int i = 0; i &lt; rows; ++i) &#123; for (int j = 0; j &lt; cols; ++j) &#123; img.at&lt;uchar&gt;(i, j) = getdata(f); &#125; &#125; imshow("img", img); imwrite("result.jpg", img); waitKey(0); return 0;&#125;uchar getdata(fstream &amp;f)&#123; static int data_cnt = 0; int val; if (data_cnt == 0) &#123; while (1) &#123; f &gt;&gt; val; if (val == 253) break; &#125; &#125; f &gt;&gt; val; ++data_cnt; if (data_cnt == 64) data_cnt = 0; return uchar(val);&#125; 运行之后就可以看到你之前的图片了]]></content>
  </entry>
  <entry>
    <title><![CDATA[随机变量及其分布]]></title>
    <url>%2Funcategorized%2F%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83%2F</url>
    <content type="text"><![CDATA[离散型 0 - 1 分布 分布律 $$ P \lbrace x = k \rbrace = p^k (1-p)^{1-k}, (k = 0, 1; 0 &lt; p &lt; 1)$$ 二项分布 分布律 $ X \sim b(n, p) $ $$ P \lbrace x = k \rbrace = C_n^k p^k(1-p)^{1-k}, (k = 0, 1, 2, \cdots) $$ 泊松分布 分布律 $ X \sim \pi(\lambda) $ $$ P \lbrace x = k \rbrace = \cfrac{\lambda^ke^{-\lambda}}{k!}, (k = 0, 1, 2, \cdots; \lambda &gt; 0) $$ 泊松定理 设 $ \lambda &gt; 0 $ 是一个常数，$ n $ 是任意正整数，设 $ np_n = \lambda $，则对于任一固定的非负整数 $ k $，有 $$ \lim_{n \to \infty} C_n^k p_n^k (1-p_n)^{n-k} = \cfrac{\lambda^k e^{-\lambda}}{k!} $$ 证： 由 $ n p_n = \lambda $ 可得 $ p_n = \cfrac{\lambda}{n} $所以$$C_n^k p_n^k (1-p_n)^{n-k} = \cfrac{n \cdot (n-1) \cdot (n-2) \cdots (n-k+1)}{k!}(\cfrac{\lambda}{n})^k(1 - \cfrac{\lambda}{n})^{n-k}$$ $$= \cfrac{\lambda^k}{k!}[1 \cdot (1-\cfrac{1}{n}) \cdot (1 - \cfrac{2}{n}) \cdots(1 - \cfrac{k-1}{n})] (1-\cfrac{\lambda}{n})^n(1-\cfrac{\lambda}{n})^{-k}$$ 所以 $$\lim_{n\to\infty}C_n^kp_n^k(1-p_n)^{n-k}=\cfrac{\lambda^k}{k!}\cdot1\cdot e^{-\lambda} \cdot 1 = \cfrac{\lambda^ke^{-\lambda}}{k!}$$ 这说明以 $ n $, $ p $ 为参数的二项分布的概率值可以用参数为 $ \lambda = np $ 的泊松分布近似 连续型 均匀分布 概率密度函数 $ X \sim U(a,b) $ $$f(x)=\begin{cases}\cfrac{1}{b-a},&amp;b&gt;x&gt;a \0,&amp;otherwise\end{cases}$$ 指数分布 概率密度函数 $$f(x)=\begin{cases}\cfrac{1}{\theta} e^{-\frac{x}{\theta}},&amp;x&gt;0 \0,&amp;otherwise\end{cases}$$ 性质 无记忆性：$$P\lbrace X &gt; s + t | X &gt; s \rbrace = P\lbrace X &gt; t \rbrace$$ 证： $$P\lbrace X &gt; s + t | X &gt; s \rbrace = \cfrac{P\lbrace (X &gt; s + t) \bigcap (X &gt; s) \rbrace}{P\lbrace X &gt; s \rbrace }$$ $$= \cfrac{P\lbrace X &gt; s + t \rbrace}{P\lbrace X &gt; s \rbrace }$$ $$= \cfrac{1-F(s+t)}{1-F(s)}$$ $$= \cfrac{e^{-(s+t)/\theta}}{e^{-s/\theta}}$$ $$= e^{-t/\theta}$$ $$= P\lbrace X &gt; t \rbrace$$ 正态分布 概率密度函数 $ X \sim N(\mu, \sigma^2) $ $$f(x) = \cfrac{1}{\sqrt{2\pi}\sigma} e^{-\frac{(x-\mu)^2}{2\sigma^2}}, -\infty &lt; x &lt; \infty$$ 对概率密度函数的积分 令 $ t = \cfrac{x-\mu}{\sigma} $, 则有 $$\int_{-\infty}^{\infty}\cfrac{1}{\sqrt{2\pi}\sigma} e^{-\frac{(x-\mu)^2}{2\sigma^2}} \mathrm{d}x = \cfrac{1}{\sqrt{2\pi}}\int_{-\infty}^{\infty}e^{-\frac{t^2}{2}} \mathrm{d}t$$ 令 $ I = \int_{-\infty}^{\infty}e^{-\frac{t^2}{2}} \mathrm{d}t $, 则有 $$I^2 = \int_{-\infty}^{\infty}\int_{-\infty}^{\infty} e^{-\frac{t^2+u^2}{2}}\mathrm{d}t\mathrm{d}u$$ 化为极坐标 $$I^2 = \int_0^{2\pi} \int_0^\infty e^{-\frac{r^2}{2}}r\mathrm{d}r\mathrm{d}\theta = 2\pi$$ 由于 $ I &gt; 0 $, 所以 $ I = \sqrt{2\pi} $ 所以 $$\int_{-\infty}^{\infty}\cfrac{1}{\sqrt{2\pi}\sigma} e^{-\frac{(x-\mu)^2}{2\sigma^2}} \mathrm{d}x = 1$$ 概率密度函数的拐点 对概率密度函数求二阶导, 可得 $$f^{\prime\prime}(x) = \cfrac{-1}{\sqrt{2\pi}\sigma^3}[1-\cfrac{(x-\mu)^2}{\sigma^2}]e^{-\frac{(x-\mu)^2}{2\sigma^2}}$$ 可以看出，当 $x = \mu \pm \sigma $ 时， $ f^{\prime\prime}(x) = 0 $即在 $ x = \mu \pm \sigma $ 处，曲线有拐点 随机变量的函数 设随机变量 $ X $ 具有概率密度 $ f_X(x), \infty&gt;x&gt;-\infty $，又设 $ g(x) $ 处处可导且恒有 $ g^\prime(x)&gt;0 $ （ 或恒有 $ g^\prime(x)&lt;0 $ ），则 $ Y=g(X) $ 是连续型随机变量，其概率密度为 $$f_Y(y)=\begin{cases}f_X[h(y)]|h^\prime(y)|, &amp;\beta &gt; y &gt; \alpha\0, &amp;otherwise\end{cases}$$ 其中 $ \alpha = min \lbrace g(-\infty),g(\infty) \rbrace $ ， $ \beta = max \lbrace g(-\infty),g(\infty) \rbrace $ ， $ h(y) $ 是 $ g(x) $ 的反函数.]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于学习音乐的一个重要问题--练耳]]></title>
    <url>%2Funcategorized%2F%E5%85%B3%E4%BA%8E%E5%AD%A6%E4%B9%A0%E9%9F%B3%E4%B9%90%E7%9A%84%E4%B8%80%E4%B8%AA%E9%87%8D%E8%A6%81%E9%97%AE%E9%A2%98-%E7%BB%83%E8%80%B3%2F</url>
    <content type="text"><![CDATA[这篇文章是徐大大大大大大清写的，我觉得很有用 我的问题究竟在哪里？许多同学存在这样的疑问： 弹琴是不是一定要找谱子？为什么有的人一听就能弹出来？这是不是境界非常高，或者天赋异禀？我也可以做到吗？ 为什么有的人听一听就知道歌曲的和弦？ 为什么我好像练了一些东西，但还是没法跟着伴奏做简单的即兴？ 为什么我辛辛苦苦学了这么多乐理却好像没什么用？ 这些问题都来自于一个环节的缺陷：练耳 练耳：即训练听力，即训练对听到的音乐事件的辨识力，即听到某音乐事件后能迅速准确地反映或描述的能力。 说白了，就是你听到一个旋律，或者和弦进行，或者节奏，你就知道它其中的具体内容，到底是哪几个音，哪几个和弦，哪种节奏型。 你可能会发问：这不是专业学音乐的才学的东西吗？而且听起来就很难很神秘，不是一般人能做到的啊，普通人学乐器需要学这个吗？ 这样的想法非常普遍，可以理解，但是它不对。辨识音乐事件的能力很少人有，但是这不是因为它难，而是因为目前大部分的音乐培训机构，上课的主要内容就是乐器演奏技术和对着谱子练习，却不重视练耳，甚至不教乐理。这其实是非常错误的，但是似乎少有人知道。 学习音乐的正确观念学习音乐，学习乐器的基本观点应该是：学乐器/音乐，先学乐理。学乐理，先练听力。学音乐最重要的不是喉咙，不是手指，甚至不是大脑，而是耳朵，或者说耳朵和大脑思维的结合。 没有乐理知识的支撑，弹琴基本等于单纯的手指运动，枯燥而低效，想弹一个曲子，只能到处找乐谱。而没有听力作为基础，乐理就是无用的知识，以文字的形式存在于你的脑海中，你听不到你学的知识，更无从运用。你永远无法真正理解你所听到和演奏的东西。 比方说，我今天学了一个C自然大调音阶，我会在吉他上把它弹出来，但是我却无法脱离吉他判断我正在弹的是哪一个音。我学了一个C和弦，我甚至知道C和弦是哪几个音组成的，他们的关系是怎样，但是我却回忆不起来它听起来确切是什么样的。我学了一首曲子，弹的很完美，但是过了几个月不练，我又忘记我的左手应该按到第几品，右手弹哪根弦了。 这样有什么意义呢？我似乎学会了如何演奏它，甚至知道它其中的确切关系，物理规律，但是在我却不能准确地回忆起它听起来是什么感觉，更无法在听到的音乐中辨识它，更无从在创造中运用它。 但是，如果我重视听力，平时有意识地练耳，我学习了一个音阶，就不仅仅是知道怎么把它从低到高弹出来，而是把每一个音高的具体位置记在脑海中。这样，当我听到一段旋律，甚至和弦等等，我就能辨识出它是哪些音，并且运用我的乐器把它再现，而不需要去找乐谱，这该多好！ 你可能会想：这对我来说太难了，似乎不可能做到。但我要说的是，这不是因为你做不到，而是因为你没有练习听力的意识！不是做不到，而是没有意识。只要你有这个意识，以正确的方法练习，想要收获进步，获得听音的能力，并不是你想的那么难。 听音究竟是怎么回事？首先让我们再次回顾刚刚提到的“听了一下就能弹出来”究竟是怎么一回事：第一步是听音，辨识出听到的音乐里的音乐事件（音，节奏，和声等等）并且记住。第二步是把听到的音弹出来，这就运用了乐器演奏技术的知识。显而易见的是，第一步是我们的重点所在，是我们想要获得的能力。这么说你可能还是有点迷糊，我怎么才听得出来呢？ 那我们就要再说得细一点，把听音的过程再拆分：“辨识”，其实就是认出来你熟悉的东西，好比我已经认识我的一个朋友，他叫张三，那么我看到他的时候我才能叫他张三。如果我压根不认识他，我看到他的时候怎么能叫他张三？听力也是一样，只有你已经熟悉了这个音听起来是什么感觉，听到它的时候才能辨认出来。这么一说，相信你应该明白了：练耳，其实就是把你想要辨认的事件拿出来，一遍遍地记忆，熟悉它，这样当你听到它，你就能认出它。 这就是所谓的听音能力，本质上是一种记忆，而不是听力。 是不是很清楚了？这样一来，练习的方法也很明显了：那就是通过各种方式熟悉各种音乐事件。 具体一点，我该怎么练习？让我们从最基础的音级练习开始：所有刚开始学乐器或者从来没有过听力练习的学习者都应该做这样的练习。 现在你拥有一个自然大调音阶，do，re，mi，fa，sol，la，ti。不管你使用钢琴，吉他，或者手机上的数码钢琴，以及任何能发出正确的音高的乐器演奏出来都可以，先从低到高弹几遍，让它在你的脑海中有个大概的印象。 然后我们就可以开始了： 从re开始，先弹一个re，一边弹，一边“模唱”，也就是模仿它的音高唱，让你的音调接近你弹出来的音直到重合，即使不好听也不要紧，轻轻哼一下也可以，只要音调一样。好，你做到了，非常不错！ 再弹一下do，集中注意力记忆你刚刚弹和唱的re相对于do是什么样的感觉，它的具体高度是怎样的。没错！我们并不是记忆“单个的音”，而是记忆它相对于do的位置！因为所有的音都是以它为中心和参照的。然后重复这个过程，直到你认为自己记住了为止。 后面的mi, fa, sol等等，也是用一样的方法去练习！ 归纳起来就是模唱和记忆这简单的两步，是不是非常容易呢？这就是最基本的练习方法：刻意熟悉，或者叫刻意记忆。 构唱在完成一个音的记忆以后，你可以给自己“听写”一下来巩固，就像记单词一样，你认为自己记住了，但是到了听写的时候，脱离了单词本，你可能会发现你并没有记得很牢固。所以我们一定要脱离乐器，“默写”这个音，才能达到记忆的效果。 业内人士称之为“构唱”，构造的构，什么意思呢？比如我先出一个题：唱do-fa，所谓构就是自己构造事件，我是已经知道了要唱的音，再唱出来，注意要直接唱，中间不要经过其他的音。刚开始唱可能会有点吃力，毕竟不是那么熟悉，你可以借助乐器弹奏出来，校准你唱的音调。 是不是很简单呢？就像记单词一样，先照着单词写，重复一下，再自己回想着写出来。不同的只是单词可以理性地用音节来拆分，但是音级是凭感性思维去感受和记忆的。 其他内容也是一样！自然小调（别忘了你刚刚只是练了大调！），节奏，音程，和弦等等，都可以用同样的理念和方法来练习，总之围绕“熟悉”去练习、记忆！学了什么就应该听什么，记什么！ 其他有趣而必要的方法一直重复刚刚的练习一定会让你感到枯燥无味，不想继续练了，而且只做上面的练习也不能保证实用性，所以我们需要一些有趣的补充练习来丰富我们的练习内容，保持练习的趣味性，动力和有效性。 重复已知事件：唱你喜欢的歌！找出你学过的儿歌，两只老虎，小星星，或者是你喜欢的歌曲或器乐作品的简谱，最好是简单好唱的，用唱名（do re mi等等）唱出来，并记忆每一个音高，重复这个过程，加深印象；最好用乐器同步弹奏，保证你记忆的音是准确的。 这样练习的优点是比基础的模唱和构唱更有趣，同时也达到了记忆的目的，平时没事就可以唱唱，轻松记忆。 扒带（听辨）实践：自己找音！扒带，即辨识你在音乐作品中听到的音乐事件，比如听到一个旋律然后辨识其中的音，听到一个和声进行辨识其中的和弦等等。这是理解音乐需要的最基本能力，非常重要。这也是我们练耳的最终目的。 实际上，扒带本身并不能让你取得进步，但是它可以辅助你的进步，让你的练习更有方向性和趣味性。第一次不借助乐谱弹奏出自己喜欢的音乐的感觉简直无与伦比，伙计！ 是的！即使是初学者也可以尝试着扒带。不过还是建议有一点音级和歌曲的积累，脑中有一个自然大小调的音阶体系以后开始，这样你更容易感觉出do的位置，否则你必须先通过其他方式知道它是哪一个调的音乐。 具体怎么扒带呢？首先我们要知道我们要辨识的是哪一个音，对于初学者来说，可能第一个音就很难直接听出来，那么我们就从第一个音开始： 听一下这个音，然后马上按下暂停！后面的音很可能干扰你对这个音的印象。然后模唱这个音，把它拉长，以加深它在你脑中的印象，防止忘记。好了，现在你已经牢牢记住了这个音的感觉。感受一下它在do的上方还是下方。 从do（调式主音，小调就从la）开始，一级一级地递推，比如往上，re, mi, fa, sol…la！感觉和刚刚那个音一样！那么恭喜你，你已经找到了这个音是什么，后面的音也是同样的方法！ 刚刚我们说了，扒带本身也许并不能让你在听力上进步，也就是更熟悉某个音，但是却可以提醒你，这个音，或者这几个音组合起来的感觉，你还不够熟悉，这样你就可以有针对性地练习你的弱势（你也可以把它当做一个练习效果的小测验，让你看到你的进步）； 另外，它能告诉你音乐作品里会用到哪些音（事件），哪些不会用到，这样你就不会去记忆一些根本不需要的音，让你练得更有方向性！你也不需要再去到处找乐谱了！所以扒带的好处是非常多的。 想想看，听辨大师的作品，就像和大师对话，尝试理解他的思维，这是一件非常美好而有趣的事，不是吗？ 练习的合理安排就像背单词一样，记忆音高或是节奏也需要合理安排时间，不要一次性练习太多内容，记忆是有限的，注重日积月累！大脑也需要休息。如果每天练习四十分钟，那你可以把它拆分成两个二十分钟，也可以穿插练习不同的东西来放松一下。 另外，和背单词一样，如果不复习就会忘记，所以不要忘记复习你昨天和前天练习的内容，常常巩固一下！你可以利用歌曲或者器乐作品来重复你已经建立的印象，巩固记忆。]]></content>
  </entry>
  <entry>
    <title><![CDATA[minAreaRect函数返回值说明]]></title>
    <url>%2Funcategorized%2FminAreaRect%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E8%AF%B4%E6%98%8E%2F</url>
    <content type="text"><![CDATA[最近在看代码的时候发现 OpenCV 里面 minAreaRect() 这个函数返回的旋转矩形的 angle, height, width 有点让人困惑，不清楚为什么它们的值是那么多，网上找的解释竟然解释的还不一样，于是就自己写代码验证了一下，我也不知道对不对，欢迎评论指正 先放几张测试图片 Result其实从图片上看，结果已经很明确了，minAreaRect() 返回的旋转矩形有如下特征 angle = 过旋转矩形中心的直线(绿线)逆时针旋转，当它第一次与旋转矩形的边垂直时，该直线旋转过的角度的相反数即为 angle 的值 width = 与旋转直线(绿线)第一次垂直的那两条边的长度，即为 width 的值 height = 不是 width 的那两条边的长度，即为 height 的值咯 Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;opencv2/opencv.hpp&gt;#include &lt;vector&gt;using namespace cv;int main()&#123; Mat img(500, 500, CV_8UC3); RNG &amp;rng = theRNG(); while (1) &#123; int count = rng.uniform(1, 101); std::vector&lt;Point2f&gt; points; for (int i = 0; i &lt; count; ++i) &#123; Point2f pt; pt.x = rng.uniform(img.size().width / 4, img.size().width * 3 / 4); pt.y = rng.uniform(img.size().height / 4, img.size().height * 3 / 4); points.push_back(pt); &#125; RotatedRect rect = minAreaRect(Mat(points)); Point2f rectPoints[4]; rect.points(rectPoints); img = Scalar::all(0); for (int i = 0; i &lt; count; ++i) &#123; circle(img, points[i], 3, Scalar(0, 0, 255), FILLED, LINE_AA); &#125; for (int i = 0; i &lt; 4; ++i) &#123; line(img, rectPoints[i], rectPoints[(1 + i) % 4], Scalar(255, 0, 0), 3, LINE_AA); &#125; line(img, Point2f(rect.center.x, 0), Point2f(rect.center.x, img.size().height), Scalar(0, 255, 0), 2, LINE_AA); char text[50]; sprintf(text, "angle: %.2f, width: %.2f, height: %.2f", rect.angle, rect.size.width, rect.size.height); putText(img, text, Point(2, 15), CV_FONT_NORMAL, 0.5, Scalar(255, 255, 255)); imshow("img", img); if (waitKey(0) == 27) &#123; break; &#125; &#125; return 0;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04LTS下编译安装OpenCV]]></title>
    <url>%2Funcategorized%2FUbuntu16-04LTS%E4%B8%8B%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85OpenCV%2F</url>
    <content type="text"><![CDATA[Ubuntu16.04LTS下编译安装OpenCV 这篇教程是陈明聪学长写的，这里放在我的博客上供以后参考 添加了 OpenCV_Contrib 的编译安装 Pre.前期准备下载OpenCV 和 OpenCV_Contrib 源码包进入OpenCV官方下载页面选择Sources类型下载OpenCV_Contrib 的源码去 Github 上找找，我也忘了我在哪下的了，下的版本要跟 OpenCV 一样… 1.安装依赖包12sudo apt-get install cmakesudo apt-get install build-essential libgtk2.0-dev libavcodec-dev libavformat-dev libjpeg.dev libtiff4.dev libswscale-dev libjasper-dev 2.编译OpenCV解压之前下载好的源码包12unzip opencv-3.4.3.zip #这里以opencv-3.4.3为例unzip opencv_contrib-3.4.3.zip -d /opencv-3.4.3 #把 opencv_contrib 解压到 opencv 源码目录下 进入OpenCV源码目录123456cd opencv-3.4.3mkdir buildcd buildcmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local -D OPENCV_EXTRA_MODULES_PATH=../opencv_contrib-3.4.3/modules ..sudo make -j4sudo make install 3.添加路径首先将OpenCV的库添加到路径，从而可以让系统找到1sudo gedit /etc/ld.so.conf.d/opencv.conf 执行此命令后打开的可能是一个空白文件，不用管，只用在文件末尾添加1/usr/local/lib 执行如下命令使得刚才的配置路径生效1sudo ldconfig 配置bash1sudo gedit /etc/bash.bashrc 在最末尾添加12PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/lib/pkgconfigexport PKG_CONFIG_PATH 保存，执行如下命令使得配置生效1source /etc/bash.bashrc 更新1sudo updatedb 4.测试至此所有的配置都已经完成下面用一个小程序测试一下cd到opencv-3.4.3/samples/cpp/example_camke目录下我们可以看到这个目录下官方已经给出了一个cmake的example我们可以拿来测试下按顺序执行 123cmake .make./opencv_example 即可看到打开了摄像头，在左上角有一个hello opencv，即表示配置成功]]></content>
  </entry>
  <entry>
    <title><![CDATA[树莓派下编译安装OpenCV-3.4.1]]></title>
    <url>%2Funcategorized%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%8B%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85OpenCV-3-4-1%2F</url>
    <content type="text"><![CDATA[树莓派下编译安装OpenCV-3.4.1 首先建议先更换软件源，这里以清华的源为例 使用管理员权限，编辑/etc/apt/sources.list文件 1sudo nano /etc/apt/sources.list 用#注释掉原文件的内容，用以下内容取代 12deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main contrib non-free rpideb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ stretch main contrib non‐free rpi 使用管理员权限，编辑/etc/apt/sources.list.d/raspi.list 1sudo nano /etc/apt/sources.list.d/raspi.list 用#注释掉原文件的内容，用以下内容取代 12deb http://mirror.tuna.tsinghua.edu.cn/raspberrypi/ stretch main uideb‐src http://mirror.tuna.tsinghua.edu.cn/raspberrypi/ stretch main ui 更新软件源列表 1sudo apt-get update 为了充分使用整个存储空间，输入以下命令，进入到软件配置工具后，选择第七项 “Advanced Options” ，再选择 A1 项 “Expand Filesystem” 即可 1sudo raspi-config 先更新一下 软件源更新 1sudo apt‐get update 升级本地所有安装包 1sudo apt‐get upgrade 升级树莓派固件 1sudo rpi‐update 安装构建OpenCV的相关工具 1sudo apt‐get install build‐essential cmake git pkg‐config 安装常用图像工具包 12345678#安装jpeg格式图像工具包 sudo apt‐get install libjpeg8‐dev#安装tif格式图像工具包 sudo apt‐get install libtiff5‐dev#安装JPEG‐2000格式图像工具包 sudo apt‐get install libjasper‐dev#安装png格式图像工具包 sudo apt‐get install libpng12‐dev 安装视频I/O包（注意最后一个包的数字“4”后面是“L”) 1sudo apt‐get install libavcodec‐dev libavformat‐dev libswscale‐dev libv4l‐dev 安装gtk2.0 1sudo apt‐get install libgtk2.0‐dev 安装优化函数包 1sudo apt‐get install libatlas‐base‐dev gfortran 下载OpenCV源码（放在家目录下） 1234wget ‐O opencv‐3.4.1.zip https://github.com/Itseez/opencv/archive/3.4.1.zipunzip opencv‐3.4.1.zipwget ‐O opencv_contrib‐3.4.1.zip https://github.com/Itseez/opencv_contrib/archive/3.4.1.zipunzip opencv_contrib‐3.4.1.zip 进入源码文件夹，新建一个名为 release 的文件夹用来存放 cmake 编译时产生的临时文件 123cd opencv-3.4.1mkdir releasecd release 设置 cmake 编译参数，安装目录默认为 /usr/local , 注意参数名，等号和参数值之间不能有空格，但每行末尾 “\” 之前有空格，参数值最后是两个英文的点，如果cmake下载缺失文件失败的话，就将release文件夹删掉，从第十步重新开始 12345sudo cmake ‐D CMAKE_BUILD_TYPE=RELEASE \‐D CMAKE_INSTALL_PREFIX=/usr/local \‐D OPENCV_EXTRA_MODULES_PATH=~/opencv_contrib‐3.4.1/modules \‐D INSTALL_PYTHON_EXAMPLES=ON \‐D BUILD_EXAMPLES=ON .. 开始编译 123456#编译sudo make#安装sudo make install#更新动态链接库sudo ldconfig 编译安装完了应该就可以了，可以写个程序测试一下 参考链接： 树莓派OpenCV3.4.1安装血泪史，分享如何规避各种坑 (树莓派、Linux通用)OpenCV3源码方式安装（最新3.4.1） 为树莓派更换国内镜像源]]></content>
  </entry>
  <entry>
    <title><![CDATA[树莓派初次使用教程]]></title>
    <url>%2Funcategorized%2F%E6%A0%91%E8%8E%93%E6%B4%BE%E5%88%9D%E6%AC%A1%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[树莓派初次使用教程 这个教程主要是针对你身边没有显示器，键盘等之类的情况，如果你有显示器，键盘等，就完全不用这么麻烦 准备材料：树莓派，网线一根，内存卡一张（建议最小16G），笔记本电脑 去树莓派官网下载系统镜像，下raspbian就行 下载Win32 Disk Imager(烧写镜像的工具) 先格式化一下你的内存卡 打开Win32 Disk Image, 在映像文件这一栏选择你刚才下载的镜像文件，再在设备中选择你的SD卡，点击写 入即可，写入后，在boot目录下新建一个名为ssh的空白文档，删掉.txt后缀。如果烧写失败，或者下一步中 启动树莓派时有问题，需要重新烧写系统时，你需要先将内存卡的分区合并，再进行烧写，合并分区的方法 如下 首先WIN+R，输入cmd进入Windows命令行 输入 1DISKPART 查看机器磁盘，输入以下命令，根据磁盘大小可以判断SD卡是哪个磁盘 1list disk 假如我这里SD卡为磁盘1，则我就需要选中磁盘1 1select disk 1 输入clean删除磁盘 1clean 创建主磁盘分区 1CREATE PARTITION PRIMARY 激活磁盘分区 1active 以FAT32格式快速格式化磁盘分区 1FORMAT FS=FAT32 QUICK 将内存卡插入树莓派，启动树莓派，并用网线与笔记本电脑相连 配置共享网络 设置 -&gt; 网络和Internet -&gt; 状态 -&gt; 网络和共享中心 -&gt; WLAN -&gt; 属性 -&gt; 共享 勾选上“允许其他网络用户通过此计算机的Internet连接来连接” 在“家庭网络连接”下拉栏中选择“以太网” 点击确定 查找树莓派IPWIN+R输入cmd进入Windows的命令行，输入 1arp -a 查看网络IP，一般来说192.168.137.1下的就是树莓派的IP地址如果你确实无法确定树莓派IP，就用以下办法 下载Advanced IP Scanner 设置好IP的扫描范围（我这用的是192.168.1.1 - 192.168.1.254, 192.168.137.1 - 192.168.137.254） 后，点击Scan 扫出来的结果中名称为raspberrypi的IP地址就是树莓派的IP地址 下载PuTTY 运行PuTTY，输入树莓派的IP，选择SSH连接，点击Open(会弹出一个警告，点击否就行) 输入用户名pi，和默认密码raspberry登陆即可，输入密码的时候没有回显 登陆后，输入 1sudo passwd root 开启root账户（会让你设置root的密码） 输入 1sudo apt-get update 更新一下 安装tightvncserver 1sudo apt‐get install tightvncserver 安装xrdp服务 1sudo apt‐get install xrdp 安装服务包 1sudo apt‐get install vnc4server 启动xrdp 1sudo /etc/init.d/xrdp start WIN+R输入mstsc，进入远程桌面连接 输入树莓派IP，点击连接 选Xvnc或Xorg，输入用户名pi和密码raspberry，点击OK 不出意外的话，应该就ojbk了 参考链接： 树莓派第一次使用（笔记本+网线） 树莓派初次使用（史上最全最详细教程！！) 使用diskpart恢复使用win32 disk imager处理过的U盘]]></content>
  </entry>
</search>
